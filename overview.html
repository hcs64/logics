<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Logics</title>

<style>
div.subbody {
  max-width:960px;
  margin-left:auto;
  margin-right:auto;
  font-family:Times, serif;
}
img {
  display: block;
  margin-left:auto;
  margin-right:auto;
}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: { inlineMath: [['$','$']] }
});
</script>

<script type="text/javascript" src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML"></script>

</head>

<body>
<div class="subbody">
<h1>Modal logics, temporal and dynamic</h1>
<small>by Adam Gashlin</small>

<h2>Overview</h2>
<p>
This report deals with a branch of formal logic called
Modal Logic, in which we are concerned with the truth of propositions in
different situations, and how those situations relate to each other logically.
Example situations include points in time, conceivable worlds,
believable knowledge, and states of a computation.</p>
<p>
There is a good deal of theoretical mechanism that applies equally well to many
kinds of Modal Logic, such as a the unifying Kripke semantics. The essential
core of Kripke semantics is a binary relation on the situational
&quot;worlds&quot;, which defines how propositions in one world may be
referenced by propositions in another. This report examines in detail two
particular families of modal logic, Temporal Logic and Dynamic Logic.
</p>
<p>
In temporal logic truth is given for particular points in time.
Times are related by
&quot;<i>s</i> is in the past of <i>t</i>&quot; and
&quot;<i>s</i> is in the future of <i>t</i>&quot;.
We can express statements with reference to some or all
times, future or past, such as
&quot;<i>p</i> or <i>q</i> will be true&quot; or
&quot;if <i>r</i> was always true, <i>r</i> is true&quot;.
These are useful, for instance, for verifying the eventual proper behavior of
programs,
invariants such as &quot;if the operating system gets a request, the request
will be granted&quot;.
</p>

<p>
In dynamic logic, truths hold for states of an executing program,
and the relations are the input/output relation of each program.
This lets us express such statements as
&quot;when program <i>a</i> finishes, <i>p</i> is true&quot; and
&quot;if <i>p</i> or <i>q</i> are true, then when program <i>b</i> finishes, <i>q</i> is true&quot;.
This can be useful for formally specifying correctness properties, such as
&quot;if <i>a</i> is positive before the loop, <i>a</i> is zero after the loop
terminates&quot;.
</p>

<h2>Introduction</h2>
<h3>Formal logic</h3>
<p>
Our concern in a formal logic is to abstract away every detail that is not
necessary for preserving the validity of statements. Much reasoning is valid on
a formal level: a properly formed argument is assured to be valid by virtue of
its form.
This abstraction allows logicians to study the structure of logic apart from
dealing with the specifics of arguments, and it encourages attention to the
essential details of a situation.
</p>
<p>
Most of the operations of formal logic can be executed mechanically, to varying
degrees of effectiveness. There can be great practical value in expressing a
problem in the terms of a logic, if there are efficient automatic methods
available.
</p>

<h3>Propositions</h3>
<p>
A <i>proposition</i> is simply a statement which we regard as true or false.
An <i>atomic proposition</i> is defined to have no internal structure
that we are interested in.
<p>Consider the two atomic propositions
<ul>
<li><i>p</i> = &quot;My pants are blue&quot;</li>
<li><i>q</i> = &quot;My hair is black&quot;</li>
</ul>
By calling these atomic, we are ignoring as irrelevant any common details,
such as that both of these statements are about me and involve colors.
An atomic proposition only has an identity, like the letters <i>p</i> and
<i>q</i> here, which lets us know whether propositions can be considered
identical.</p>

<h3>Connectives</h3>
<p>
In propositional logic, we reduce statements to atomic propositions, joined by
a small family of connectives into larger propositions.
If we wanted a proposition that means &quot;my pants are blue and my hair is
black&quot;, we might introduce a new atomic proposition called <i>s</i>, but
this would be a poor choice.
For instance, it would allow us to make the statement
&quot;<i>s</i>, but not <i>p</i>&quot;. This is never true given the earlier
definition of <i>p</i> (it is a <i>contradiction</i>), but that is not clear
from the form of the statement.
</p>
<p>
Instead of <i>s</i>, we can call this proposition $p \wedge q$.
The propositional connective $\wedge$ in the middle is read as &quot;and&quot;, and the combined proposition is the statement &quot;both <i>p</i> and <i>q</i>
are true&quot;.
</p>
<p>
By using this standard method of connecting existing propositions to name a
new one, we get a name that is much more useful. If we know that both
proposition <i>p</i> and proposition <i>q</i> are true, we automatically know
that proposition $p \wedge q$ is true, without having to look up any details
about what these propositions mean.
Likewise the contradiction from earlier would be expressed as
&quot;$p \wedge q$ but not <i>p</i>&quot;, in which the
contradiction is immediately apparent.
</p>
<!--
<p>
We use $\neg p$ to mean &quot;not <i>p</i>&quot;, so the contradiction
would be stated fully formally as $p \wedge q \wedge \neg p$.
</p>
-->

<h3>Evaluation</h3>
<p>
We haven't said yet what color my hair or pants actually are. There are some
statements whose truth doesn't depend on the truth of the atomic propositions,
for instance contradictions are always false and their opposite,
<i>tautologies</i>, are always true. But for everything else, the truth value of
a proposition depends on the truth values of the atomic propositions it is made
from.
</p>
<p>
The process of determining the truth value is <i>evaluation</i>, and it
proceeds according to the structure of a statement. For a statement like the
$p \wedge q$ we have been considering, consult this handy <i>truth table</i>:

$$\begin{array}{c|c|c} \varphi &amp; \psi &amp; \varphi \wedge \psi \\ \hline
\text{T} &amp; \text{T} &amp; \text{T} \\ \hline
\text{T} &amp; \text{F} &amp; \text{F} \\ \hline
\text{F} &amp; \text{T} &amp; \text{F} \\ \hline
\text{F} &amp; \text{F} &amp; \text{F} 
\end{array}$$
<p>The Greek letters $\varphi$ (phi) and $\psi$ (psi) here are used to indicate
any proposition, not just an atomic proposition.
In $p \wedge q$, $\varphi = p$ and $\psi = q$. If $\varphi$ is <b>T</b>rue and $\psi$ is <b>F</b>alse, $\varphi \wedge \psi$ is <b>F</b>alse.</p>
<p>The benefit of this method over saying &quot;$\wedge$ is 'and'&quot; is
that the table leaves no room for interpretation. While there may not be many
ways of interpreting &quot;and&quot;, consider &quot;or&quot;, which is written
as $\vee$ in propositional logic, and which has this truth table:
$$\begin{array}{c|c|c} \varphi &amp; \psi &amp; \varphi \vee \psi \\ \hline
\text{T} &amp; \text{T} &amp; \text{T} \\ \hline
\text{T} &amp; \text{F} &amp; \text{T} \\ \hline
\text{F} &amp; \text{T} &amp; \text{T} \\ \hline
\text{F} &amp; \text{F} &amp; \text{F} 
\end{array}$$
In English it is not unusual for &quot;x or y&quot; to exclude the case where
both x and y are true, but the truth table tells us unambiguously that
$\varphi$ <b>T</b>rue and $\psi$ <b>T</b>rue makes $\varphi \vee \psi$ <b>T</b>rue.
</p>

<p>Consider a more complicated statement such as
$(\neg p \wedge q) \vee (p \wedge \neg q)$.
First off, $\neg q$ means &quot;not q&quot;, which has the short truth table
$$\begin{array}{c|c} \varphi &amp; \neg \varphi \\ \hline
\text{T} &amp; \text{F} \\ \hline
\text{F} &amp; \text{T}
\end{array}$$
At this point it is helpful to think of each of the atomic propositions
<i>p</i> and <i>q</i> as simply something that can be true or false.
If we say that <i>p</i> is true and <i>q</i> is false, this forms our
<i>model</i> for the state of the world, our model is formed from the
<i>valuation</i> &quot;<i>p</i> is true, <i>q</i> is false&quot;.
To evaluate $(\neg p \wedge q) \vee (p \wedge \neg q)$, we break it down until
we arrive at statements whose truth can be determined directly from the model,
then we build back up to the full statement. This can be pictured as building
a tree 
<br><br>
<img src="xor_tree_build.png">
<br><br>
and filling it with truth values.
<br><br>
<img src="xor_tree_eval.png">

Thus for the this model, with the valuation
&quot;<i>p</i> is true, <i>q</i> is false&quot;, 
$(\neg p \wedge q) \vee (p \wedge \neg q)$ is true.
</p>

<h3>Evaluation by definition</h3>

<p>
Formally, we treat evaluation as extending the valuation to cover all possible
propositions formed from the atomic propositions. 

If a proposition $\varphi$ is true in model $\frak{M}$, we write
$\frak{M} \Vdash \varphi$. 
<br><br>
$
\begin{align}
\frak{M} &amp; \Vdash p &amp;&amp;
\text{ if $p$ is a true atomic proposition} \\

\frak{M} &amp; \Vdash \neg \varphi &amp;&amp;
\text{ if $\frak{M} \Vdash \varphi$ is not true} \\

\frak{M} &amp; \Vdash \varphi \wedge \psi &amp;&amp;
\text{ if $\frak{M} \Vdash \varphi$ and $\frak{M} \Vdash \psi$} \\

\frak{M} &amp; \Vdash \varphi \vee \psi &amp;&amp;
\text{ if one or both of $\frak{M} \Vdash \varphi$ and $\frak{M} \Vdash \psi$}
\end{align}
$
<br><br>
Note that only one of these rules applies for every possible proposition,
so if the left hand side matches the form of a proposition but the condition on 
the right hand side doesn't hold, then the proposition is false.
</p>

<!--
<h3>Implication</h3>
Often propositional logic is defined in terms of only one connective,
$\rightarrow$, &quot;implies&quot;, and an atomic proposition that is always
false, $\bottom$, &quote;falsum&quot;. The connectives we have been seeing,
$\wedge$, $\vee$ and $\neg$, can then be considered as 
-->

</div>
</body>
</html>
