<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Logics</title>

<style>
div.subbody {
  max-width:960px;
  margin-left:auto;
  margin-right:auto;
  font-family:serif;
}
img {
  display: block;
  margin-left:auto;
  margin-right:auto;
}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: { inlineMath: [['$','$']] }
});
</script>

<script type="text/javascript" src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML"></script>

</head>

<body>
<div class="subbody">
<h1>Modal logics, temporal and dynamic</h1>
<small>Adam Gashlin</small>

<h2>Contents</h2>
<ul>
<li><a href="#intro">Propositional logic</a></li>
<li><a href="#modal">Modal logic</a></li>
</ul>

<h2>Overview</h2>
<p>
This report deals with a branch of formal logic called
Modal Logic, in which we are concerned with the truth of propositions in
different situations, and how those situations relate to each other logically.
Example situations include points in time, conceivable worlds,
believable knowledge, and states of a computation.</p>
<p>
There is a good deal of theoretical mechanism that applies equally well to many
kinds of Modal Logic, such as a the unifying Kripke semantics. The essential
core of Kripke semantics is a binary relation on the situational
&quot;worlds&quot;, which defines how propositions in one world may be
referenced by propositions in another. This report examines in detail two
particular families of modal logic, Temporal Logic and Dynamic Logic.
</p>
<p>
In temporal logic truth is given for particular points in time.
Times are related by
&quot;<i>s</i> is in the past of <i>t</i>&quot; and
&quot;<i>s</i> is in the future of <i>t</i>&quot;.
We can express statements with reference to some or all
times, future or past, such as
&quot;<i>p</i> or <i>q</i> will be true&quot; or
&quot;if <i>r</i> was always true, <i>r</i> is true&quot;.
These are useful, for instance, for verifying the eventual proper behavior of
programs,
invariants such as &quot;if the operating system gets a request, the request
will be granted&quot;.
</p>

<p>
In dynamic logic, truths hold for states of an executing program,
and the relations are the input/output relation of each program.
This lets us express such statements as
&quot;when program <i>a</i> finishes, <i>p</i> is true&quot; and
&quot;if <i>p</i> or <i>q</i> are true, then when program <i>b</i> finishes, <i>q</i> is true&quot;.
This can be useful for formally specifying correctness properties, such as
&quot;if <i>a</i> is positive before the loop, <i>a</i> is zero after the loop
terminates&quot;.
</p>

<hr>

<h2 id="intro">Propositional logic</h2>
<h3>Formal logic</h3>
<p>
Our concern in a formal logic is to abstract away every detail that is not
necessary for preserving the validity of statements. Much reasoning is valid on
a formal level: a properly formed argument is assured to be valid by virtue of
its form.
This abstraction allows logicians to study the structure of logic apart from
dealing with the specifics of arguments, and it encourages attention to the
essential details of a situation.
</p>
<p>
Most of the operations of formal logic can be executed mechanically, to varying
degrees of effectiveness. There can be great practical value in expressing a
problem in the terms of a logic, if there are efficient automatic methods
available.
</p>

<h3>Propositions</h3>
<p>
A <dfn>proposition</dfn> is simply a statement which we regard as true or
false.
An <dfn>atomic proposition</dfn> is defined to have no internal structure
that we are interested in.
</p>
<p>
Consider the two atomic propositions
</p>
<ul>
<li><i>p</i> = &quot;My pants are blue&quot;</li>
<li><i>q</i> = &quot;My hair is black&quot;</li>
</ul>
<p>
By calling these atomic, we are ignoring as irrelevant any common details,
such as that both of these statements are about me and involve colors.
An atomic proposition only has an identity, like the letters <i>p</i> and
<i>q</i> here, which lets us know whether propositions can be considered
identical.</p>

<h3>Connectives</h3>
<p>
In propositional logic, we reduce statements to atomic propositions, joined by
a small family of connectives into larger propositions.
If we wanted a proposition that means &quot;my pants are blue and my hair is
black&quot;, we might introduce a new atomic proposition called <i>s</i>, but
this would be a poor choice.
For instance, it would allow us to make the statement
&quot;<i>s</i>, but not <i>p</i>&quot;. This is never true given the earlier
definition of <i>p</i> (it is a <dfn>contradiction</dfn>),
but that is not clear from the form of the statement.
</p>
<p>
Instead of <i>s</i>, we can call this proposition $p \wedge q$.
The propositional connective $\wedge$ in the middle is read as &quot;and&quot;, and the combined proposition is the statement &quot;both <i>p</i> and <i>q</i>
are true&quot;.
</p>
<p>
By using this standard method of connecting existing propositions to name a
new one, we get a name that is much more useful. If we know that both
proposition <i>p</i> and proposition <i>q</i> are true, we automatically know
that proposition $p \wedge q$ is true, without having to look up any details
about what these propositions mean.
Likewise the contradiction from earlier would be expressed as
&quot;$p \wedge q$ but not <i>p</i>&quot;, in which the
contradiction is immediately apparent.
</p>
<!--
<p>
We use $\neg p$ to mean &quot;not <i>p</i>&quot;, so the contradiction
would be stated fully formally as $p \wedge q \wedge \neg p$.
</p>
-->

<h3>Evaluation</h3>
<p>
We haven't said yet what color my hair or pants actually are. There are some
statements whose truth doesn't depend on the truth of the atomic propositions,
for instance contradictions are always false and their opposite,
<dfn>tautologies</dfn>, are always true.
But for everything else,
the truth value of a proposition depends on
the truth values of the atomic propositions it is made from.
</p>

<div style="float:right;">$$
{\large \wedge} \\
\begin{array}{c|c|c} \varphi &amp; \psi &amp; \varphi \wedge \psi \\ \hline
\text{T} &amp; \text{T} &amp; \text{T} \\ \hline
\text{T} &amp; \text{F} &amp; \text{F} \\ \hline
\text{F} &amp; \text{T} &amp; \text{F} \\ \hline
\text{F} &amp; \text{F} &amp; \text{F} 
\end{array}
$$</div>

<p>
<br>
The process of determining the truth value is <dfn>evaluation</dfn>, and it
proceeds according to the structure of a statement. For a statement like the
$p \wedge q$ we have been considering, consult the <dfn>truth table</dfn>
to the right.

<p>The Greek letters $\varphi$ (phi) and $\psi$ (psi) here are used to indicate
any proposition, not just an atomic proposition.
In $p \wedge q$, $\varphi = p$ and $\psi = q$. If $\varphi$ is <b>T</b>rue and $\psi$ is <b>F</b>alse, $\varphi \wedge \psi$ is <b>F</b>alse.</p>

<div style="clear:right"></div>

<div style="float:right;">
$${\large \vee} \\

\begin{array}{c|c|c} \varphi &amp; \psi &amp; \varphi \vee \psi \\ \hline
\text{T} &amp; \text{T} &amp; \text{T} \\ \hline
\text{T} &amp; \text{F} &amp; \text{T} \\ \hline
\text{F} &amp; \text{T} &amp; \text{T} \\ \hline
\text{F} &amp; \text{F} &amp; \text{F} 
\end{array}
$$</div>


<p>
<br>
The benefit of this method over saying &quot;$\wedge$ is 'and'&quot; is
that the table leaves no room for interpretation. While there may not be many
ways of interpreting &quot;and&quot;, consider &quot;or&quot;, which is written
as $\vee$ in propositional logic, and which has the truth table to the right.
</p>
<p>
In English it is not unusual for &quot;x or y&quot; to exclude the case where
both x and y are true, but the truth table tells us unambiguously that
$\varphi$ <b>T</b>rue and $\psi$ <b>T</b>rue makes $\varphi \vee \psi$ <b>T</b>rue.
</p>

<div style="clear:right"></div>

<p>Consider a more complicated statement such as
$(\neg p \wedge q) \vee (p \wedge \neg q)$.
First off, $\neg q$ means &quot;not q&quot;, which has the truth table:
$\begin{array}{c|c} \varphi &amp; \neg \varphi \\ \hline
\text{T} &amp; \text{F} \\ \hline
\text{F} &amp; \text{T}
\end{array}$<br>

At this point it is helpful to think of each of the atomic propositions
<i>p</i> and <i>q</i> as simply something that can be true or false.
If we say that <i>p</i> is true and <i>q</i> is false, this forms our
<dfn>model</dfn> for the state of the world, our model is formed from the
<dfn>valuation</dfn> &quot;<i>p</i> is true, <i>q</i> is false&quot;.
To evaluate $(\neg p \wedge q) \vee (p \wedge \neg q)$, we break it down until
we arrive at statements whose truth can be determined directly from the model,
then we build back up to the full statement. This can be pictured as building
a tree 
<br><br>
<img src="xor_tree_build.png" alt="a tree is constructed from the analysis of a proposition">
<br><br>
and filling it with truth values.
<br><br>
<img src="xor_tree_eval.png" alt="truth values propagate from the leaves of a tree">

Thus for the this model, with the valuation
&quot;<i>p</i> is true, <i>q</i> is false&quot;, 
$(\neg p \wedge q) \vee (p \wedge \neg q)$ is true.
</p>

<h3>Evaluation by definition of $M \vDash \varphi$</h3>

<p>
Formally, we treat evaluation as extending the valuation to cover all possible
propositions formed from the atomic propositions. 

If a proposition $\varphi$ is true in model <i>M</i>, we write
$M \vDash \varphi$.
<br><br>
$
\begin{align}
M &amp; \vDash p &amp;&amp;
\text{ if $p$ is a true atomic proposition} \\

M &amp; \vDash \neg \varphi &amp;&amp;
\text{ if $M \vDash \varphi$ is not true} \\

M &amp; \vDash \varphi \wedge \psi &amp;&amp;
\text{ if $M \vDash \varphi$ and $M \vDash \psi$} \\

M &amp; \vDash \varphi \vee \psi &amp;&amp;
\text{ if one or both of $M \vDash \varphi$ and $M \vDash \psi$}
\end{align}
$
<br><br>
Note that only one of these rules applies for every possible proposition,
so if the left hand side matches the form of a proposition but the condition on 
the right hand side doesn't hold, then the proposition is false. If
$M \vDash \varphi$ is not true, we instead write $M \not \vDash \varphi$.
</p>

<!--
<h3>Implication</h3>
Often propositional logic is defined in terms of only one connective,
$\rightarrow$, &quot;implies&quot;, and an atomic proposition that is always
false, $\bottom$, &quote;falsum&quot;. The connectives we have been seeing,
$\wedge$, $\vee$ and $\neg$, can then be considered as 
-->

<hr>

<h2 id="modal">Modal logic</h2>

<h3>Multiple states</h3>
<p>
So far everything discussed holds for classical propositional logic as well as
modal logic.
The first place where modal logic differs is that a model can have multiple
<dfn>states</dfn>, a.k.a. &quot;situations&quot; or &quot;worlds&quot;,
whereas classical propositional logic considers only one set of truths at a
time.
</p>
<p>
As an example, say we have one state, call it <i>s</i>, where the atomic
propositions <i>p</i> and <i>q</i> are both true.
We also have a state <i>t</i>, where only <i>p</i> is true
and <i>q</i> is false.
In modal logic a model <i>M</i> has at least two components: the set of states
$S_M$ and a valuation $V_M$.
In the example, $S_M = \{s,t\}$, the two states, and $V_M$ is a
function that gives the atomic propositions that are true in a specified state:
$V_M(s) = \{p,q\}$ and $V_M(t) = \{p\}$.
</p>
<p>
To show that we are discussing truths in a particular state <i>s</i>, we write
$M \vDash_s$ instead of simply $M \vDash$. In the running example,
$M \vDash_s p$ and $M \vDash_s q$, as well as $M \vDash_t p$. However it is not
the case that $M \vDash_t q$, so we write $M \not{\vDash_t} q$. We can also
use the earlier definition of $\vDash$ to extend $\vDash_s$ and $\vDash_t$ to
larger propositions, for instance $M \vDash_s p \wedge q$ and $M \vDash_t p \wedge \neg q$.
</p>
<p>
Often we want to reason without knowing what state is the
&quot;real world&quot;.
If we find a proposition that is true across all states, we can use it without
reference to a particular state.
If this is so we say the proposition is <dfn>true in the model</dfn>,
and we write $M \vDash \varphi$ without a subscript.
In the example we have $M \vDash p$ and $M \vDash q \vee p$, for instance.
</p>

<h3>Referring to other states</h3>
<p>
The real power of modal logic comes from being able to make reference to
other states.
For this purpose we add two symbols to our proposition language:
$\newcommand{\box}{{\scriptsize \square}} \box$ (&quot;box&quot;) and $\diamond$, (&quot;diamond&quot;). These are used to prefix
other propositions to modify their interpretation.
$\box \varphi$ means that in all related states (to be defined in the next
section),
$\varphi$ is true, whereas $\diamond \varphi$ asserts that there is at least one
related state where $\varphi$ is true.
</p>
<p>
Note that $\box \varphi$ and $\diamond \varphi$ are only about related
states, they make no reference to what is true in the current state. To claim
that $\varphi$ is true in the current state and in all related states, use the
proposition $\varphi \wedge \box \varphi$.
Also note that $\box \varphi$ can be true even if there are no states where
$\varphi$ is true; this is the case when there are no related states.
</p>
<p>
We can formally define $\box$ and $\diamond$ by adding the following rules to
our definition of $\vDash$:
<br><br>
$
\begin{align}
M &amp; \vDash_s \box \varphi &amp;&amp;
\text{ if for all states $t$ where $sR_{M}t$, $M \vDash_t \varphi$ } \\
M &amp; \vDash_s \diamond \varphi &amp;&amp;
\text{ if there is a state $t$ such that $sR_{M}t$ and $M \vDash_t \varphi$ }
\end{align}
$
<br><br>

$sR_{M}t$ means that <i>s</i> is related to <i>t</i> by relation $R_{M}$, which we
will explain in the next section.

</p>

<h3>Related states</h3>
<p>
A binary relation is simply a set of ordered pairs of objects, in our case
states. The term &quot;binary&quot; here means that the relation deals with
two objects at a time, i.e. it is about pairs.
If a relation <i>R</i> contains a pair of states, then those states are
considered to be related by <i>R</i>.
For example the relation $R = \{(s,t),(s,u),(t,u),(u,t)\}$ means that
<i>s</i> is related to <i>t</i> by <i>R</i>,
which we write as <i>sRt</i>. The
converse is not true, however: it is not the case that <i>tRs</i>. Both
<i>tRu</i> and <i>uRt</i> are true.
</p>
<p>
For an example of a relation that does not hold in both directions, consider
&quot;to the right of&quot;. <i>s</i> cannot be to the right
of <i>t</i> if <i>t</i> is to the right of <i>s</i>, only one of these can be
true. In fact neither of them could be true if neither is to the right of the
other.
</p>
<p>
We are interested in relations because they specify what $\box$ and $\diamond$
mean. One way to understand a relation is that is describes a set of states that
are accessible, by $\box$ and $\diamond$, from a given state.
More on this in the examples below.
</p>
<img src="modal_example_1.png" style="float:right; margin:1em;" alt="interconnected circles representing the model">
<h4>A simple example</h4>
<p>
For a simple example (based on Harel et al. 2000 ex 5.1),
consider a model with the states<br>
$S_M = \{s,t,u\}$, with the relation<br>
$R_{M} = \{(s,t),(s,u),(t,u),(u,t)\}$, and with<br>
$V_M(s) = \{\}, V_M(t)=\{p, q\}, V_M(u)=\{p\}$.<br>
This is depicted in the diagram on the right, where circled letters are states,
arrows show relations, and colored shapes enclose states where the like-colored
propositions are true.
</p>
<p>Here, we have $M \vDash \box p$; for any state, all states <i>r</i> it is
related to (i.e. that it has an arrow pointing to) have $M \vDash_r p$.
We also have $M \vDash_s \diamond q$ and $M \vDash_u \diamond q$, but not
$M \vDash_t \diamond q$.<br>
$M \vDash_t \diamond \diamond q$ is true, though, as
there is somewhere (<i>u</i>) related from <i>t</i> that relates to somewhere
(<i>t</i> again) where <i>q</i> is true.
</p>
<h4>A neighborhood example</h4>
<p>
For a more concrete example, consider the neighborhood nine houses around
house <i>s</i> pictured on the right below. We will be considering a house as a
state in a model <i>N</i>, so $N_S = r,s,t,u,v,w,x,y,z$.
Here <i>s</i> is the neighbor of all of <i>r</i>, <i>t</i>, <i>u</i>,
<i>v</i>, <i>w</i>, <i>x</i>, <i>y</i>, and <i>z</i>. The neighbor relation we
will consider is symmetric, so <i>s</i> is a neighbor to <i>t</i> and <i>t</i>
is a neighbor back to <i>s</i>, written $sR_{N}t$ and $tR_{N}$. The complete
neighbor relation is<br>
<img src="neighborhood.png" style="clear:right;float:right; margin:1em;" alt="a 3x3 grid of houses with s in the middle">
${ \small
\begin{align} R_{N} = &amp;\{ \\
  &amp;(r,v), (r,s), (r,t), \\
  &amp;(t,r), (t,v), (t,s), (t,w), (t,u), \\
  &amp;(u,t), (u,s), (u,w), \\
  &amp;(v,r), (v,t), (v,s), (v,y), (v,x), \\
  &amp;(s,r), (s,t), (s,u), (s,v), (s,w), (s,x), (s,y), (s,z), \\
  &amp;(w,u), (w,t), (w,s), (w,y), (w,z), \\
  &amp;(x,v), (x,s), (x,y), \\
  &amp;(y,x), (y,v), (y,s), (y,w), (y,z), \\
  &amp;(z,y), (z,s), (z,w) \\
\}
\end{align}
}$
</p>

<h3 style="clear:both">Frames</h3>

</div>
</body>
</html>
